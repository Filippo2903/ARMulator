# Dictionnaire en français
dict = {
    "abstractOp": [
        "Erreur interne: ",
        "<li>Vérifie si la condition {} est remplie</li>\n",
        "L'instruction est invalide (la condition demandée n'existe pas)",
    ],

    "branchOp": [
        "Le bytecode à cette adresse ne correspond à aucune instruction valide (1)",
        "<li>Copie la valeur de {}-4 (l'adresse de la prochaine instruction) dans {}</li>\n",
        "<li>Soustrait la valeur {} à {}</li>\n",
        "<li>Additionne la valeur {} à {}</li>\n",
        "<li>Copie la valeur de {} dans {}</li>\n",
    ],

    "dataOp": [
        "Le bytecode à cette adresse ne correspond à aucune instruction valide (2)",
        "La constante {}",
        "Le registre {} {}",
        "<li>Effectue une opération ET entre:\n",
        "<li>Effectue une opération OU EXCLUSIF (XOR) entre:\n",
        "<li>Effectue une soustraction (A-B) entre:\n",
        "<li>Effectue une soustraction inverse (B-A) entre:\n",
        "<li>Effectue une addition (A+B) entre:\n",
        "<li>Effectue une addition avec retenue (A+B+carry) entre:\n",
        "<li>Effectue une soustraction avec emprunt (A-B+carry) entre:\n",
        "<li>Effectue une soustraction inverse avec emprunt (B-A+carry) entre:\n",
        "<li>Effectue une opération OU entre:\n",
        "<li>Lit la valeur de :\n",
        "<li>Effectue une opération ET NON entre:\n",
        "<li>Effectue une opération NOT sur :\n",
        "Mnémonique invalide : {}",
        "<ol type=\"A\"><li>Le registre {}</li><li>{}</li></ol>\n",
        "<ol type=\"A\"><li>Le registre {}</li>\n",
        "<li>Copie le SPSR courant dans CPSR</li>\n",
        "<li>Met à jour les drapeaux de l'ALU en fonction du résultat de l'opération</li>\n",
        "<li>Écrit le résultat dans {}</li>",
        "Mnémonique invalide : {}",
        "L'utilisation de PC comme registre de destination en combinaison avec la mise a jour des drapeaux est interdite en mode User!",
        "SPSR devrait ici être copié dans CPSR, mais le mode contenu dans SPSR est invalide!",
    ],

    "halfSignedMemOp": [
        "Le bytecode à cette adresse ne correspond à aucune instruction valide",
        "<li>Utilise la valeur du registre {} comme adresse de base</li>\n",
        "<li>Additionne la constante {} à l'adresse de base</li>\n",
        "<li>Soustrait la constante {} à l'adresse de base</li>\n",
        "<li>Additionne le registre {} à l'adresse de base</li>\n",
        "<li>Soustrait le registre {} à l'adresse de base</li>\n",
        "<li>Lit {} à partir de l'adresse obtenue (pré-incrément) et stocke le résultat dans {} (LDR)</li>\n",
        "<li>Lit {} à partir de l'adresse de base et stocke le résultat dans {} (LDR)</li>\n",
        "<li>Copie la valeur du bit {} sur les bits {} à 31 du registre de destination</li>\n",
        " de l'octet le moins significatif",
        " des 2 octets les moins significatifs",
        "<li>Copie la valeur",
        " registre {} dans la mémoire, à l'adresse obtenue à l'étape précédente (pré-incrément), sur {} (STR)</li>\n",
        "<li>Copie la valeur",
        " registre {} dans la mémoire, à l'adresse de base, sur {} (STR)</li>\n",
        "<li>Écrit l'adresse effective dans le registre de base {} (mode writeback)</li>\n",
        "Tentative de lecture de {} octets à partir de l'adresse {} invalide : mémoire non initialisée",
    ],

    "memOp": [
        "Le bytecode à cette adresse ne correspond à aucune instruction valide",
    "<li>Utilise la valeur du registre {} comme adresse de base</li>\n",
    "<li>Additionne la constante {} à l'adresse de base</li>\n",
    "<li>Soustrait la constante {} à l'adresse de base</li>\n",
    "<li>Additionne le registre {} {} à l'adresse de base</li>\n",
    "<li>Soustrait le registre {} {} à l'adresse de base</li>\n",
    "1 octet",
    "{} octets",
    "<li>Lit {} à partir de l'adresse obtenue (pré-incrément) et stocke le résultat dans {} (LDR)</li>\n",
    "<li>Lit {} à partir de l'adresse de base et stocke le résultat dans {} (LDR)</li>\n",
    "<li>Copie la valeur du registre {} dans la mémoire, à l'adresse obtenue à l'étape précédente (pré-incrément), sur {} (STR)</li>\n",
    "<li>Copie la valeur du registre {} dans la mémoire, à l'adresse de base, sur {} (STR)</li>\n",
    "<li>Écrit l'adresse effective dans le registre de base {} (mode writeback)</li>\n",
    "Tentative de lecture de {} octets à partir de l'adresse {} invalide : mémoire non initialisée",
    ],

    "mulLongOp": [
        "Le bytecode à cette adresse ne correspond à aucune instruction valide",
        "<li>Effectue une multiplication et une addition {} sur 64 bits (A*B+[C,D]) entre :\n",
        "<ol type=\"A\"><li>Le registre {}</li>\n",
        "<li>Le registre {}</li>\n",
        "<li>Le registre {}</li>\n",
        "<li>Le registre {}</li></ol>\n",
        "<li>Effectue une multiplication {} (A*B) entre :\n",
        "<ol type=\"A\"><li>Le registre {}</li>\n",
        "<li>Le registre {}</li></ol>\n",
        "<li>Met à jour les drapeaux de l'ALU en fonction du résultat de l'opération</li>\n",
        "<li>Écrit les 32 MSB du résultat dans R{} et les 32 LSB dans R{}</li>",
    ],

    "mulOp": [
        "Le bytecode à cette adresse ne correspond à aucune instruction valide",
        "<li>Effectue une multiplication suivie d'une addition (A*B+C) entre :\n",
        "<ol type=\"A\"><li>Le registre {}</li>\n",
        "<li>Le registre {}</li>\n",
        "<li>Le registre {}</li></ol>\n",
        "<li>Met à jour les drapeaux de l'ALU en fonction du résultat de l'opération</li>\n",
        "<li>Effectue une multiplication (A*B) entre :\n",
        "<ol type=\"A\"><li>Le registre {}</li>\n",
        "<li>Le registre {}</li></ol>\n",
        "<li>Met à jour les drapeaux de l'ALU en fonction du résultat de l'opération</li>\n",
        "<li>Écrit le résultat dans R{}</li>",
    ],

    "multipleMemOp": [
        "Le bytecode à cette adresse ne correspond à aucune instruction valide",
    "<li>Lit la valeur de SP</li>\n",
    "<li>Pour chaque registre de la liste suivante, stocke la valeur contenue à l'adresse pointée par SP dans le registre, puis incrémente SP de 4.</li>\n",
    "<li>Lit la valeur de SP</li>\n",
    "<li>Pour chaque registre de la liste suivante, décrémente SP de 4, puis stocke la valeur du registre à l'adresse pointée par SP.</li>\n",
    "<li>Lit la valeur de {}</li>\n",
    "<li>Pour chaque registre de la liste suivante, stocke la valeur contenue à l'adresse pointée par {reg} dans le registre, puis {incmode} {reg} de 4.</li>\n",
    "<li>Lit la valeur de {}</li>\n",
    "<li>Pour chaque registre de la liste suivante, {incmode} {reg} de 4, puis stocke la valeur du registre à l'adresse pointée par {reg}.</li>\n",
    "<li>Copie du SPSR courant dans le CPSR</li>\n",
    ],

    "nopOp": [
        "Le bytecode à cette adresse ne correspond à aucune instruction valide",
        "<li>Ne rien faire</li><li>Nonon, vraiment, juste rien</li>",
    ],

    "psrOp": [
        "Le bytecode à cette adresse ne correspond à aucune instruction valide",
        "<li>Écrit la constante {} dans {}</li>\n",
        "<li>Lit la valeur de {}</li>\n",
        "<li>Écrit les 4 bits les plus significatifs de cette valeur (qui correspondent aux drapeaux) dans {}</li>\n",
        "<li>Lit la valeur de {}</li>\n",
        "<li>Écrit cette valeur dans {}</li>\n",
        "<li>Lit la valeur de {}</li>\n",
        "<li>Écrit le résultat dans {}</li>\n",
        "Erreur : écriture de SPSR en mode 'User' (ce mode ne possede pas de registre SPSR)",
        "Erreur : les bits ({:05b}) du mode du {} ne correspondent à aucun mode valide!",
        "Erreur : tentative de changer le mode du processeur à partir d'un mode non privilégié!",
        "Erreur : lecture de SPSR en mode 'User' (ce mode ne possede pas de registre SPSR)",
    ],

    "softInterruptOp": [
        "Le bytecode à cette adresse ne correspond à aucune instruction valide",
        "<li>Changement de banque de registres vers SVC</li>\n",
        "<li>Copie du CPSR dans le SPSR_svc</li>\n",
        "<li>Copie de PC dans LR_svc</li>\n",
        "<li>Assignation de 0x08 dans PC</li>\n"
    ],

    "swapOp": [
        "Le bytecode à cette adresse ne correspond à aucune instruction valide",
        "<li>Lit {} à partir de l'adresse contenue dans {}</li>\n",
        "<li>Écrit l'octet le moins significatif du registre {} à l'adresse contenue dans {}</li>\n",
        "<li>Écrit l'octet le moins significatif de la valeur originale en mémoire dans {}</li>\n",
        "<li>Écrit la valeur du registre {} à l'adresse contenue dans {}</li>\n",
        "<li>Écrit dans {} la valeur originale de l'adresse contenue dans {}</li>\n",
        "Tentative de lecture de {} octets à partir de l'adresse {} invalide : mémoire non initialisée"
    ],

    "utils": [
        "décalé vers la gauche (mode LSL)",
        "décalé vers la droite (mode LSR)",
        "décalé vers la droite (mode ASR)",
        "permuté vers la droite avec retenue (mode RRX)",
        "permuté vers la droite (mode ROR)",
        " de {} {}",
        " du nombre de positions contenu dans {}"
    ],

    "assembler": [
        "Erreur de syntaxe",
        "Erreur de range",
        "Instruction invalide",
        "Actual PC behavior not implemented yet",
        "Format de l'instruction invalide",
        "Impossible d'interpréter l'instruction",
        "Instruction invalide",
        "Vous ne pouvez pas écrire d'instruction avant le premier mot clé SECTION; si vous souhaitez tester un extrait de code, ne déclarez aucune section.",
        "La section INTVEC doit être définie avant les sections CODE et DATA!",
        "La section CODE doit être définie avant la section DATA!",
        "La section '{}' est définie deux fois!",
        "L'étiquette '{}' est définie deux fois (première définition à la ligne {})",
        "La déclaration située sur cette ligne fait déborder la section INTVEC dans la section CODE. Vérifiez que vous allouez le bon nombre d'octets (128 octets maximum pour la section INTVEC en entier).",
        "Le code demande une allocation totale de plus de {} octets de mémoire, ce qui est invalide.",
        "La section INTVEC n'est déclarée nulle part (utilisez 'SECTION INTVEC' au début du code)!",
        "La section CODE n'est déclarée nulle part (utilisez 'SECTION CODE')!",
        "La section DATA n'est déclarée nulle part (utilisez 'SECTION DATA' à la fin de votre code)!",
        "Cette ligne demande l'adresse de l'étiquette {}, mais celle-ci n'est déclarée nulle part",
        "L'étiquette {} n'est déclarée nulle part",
        "Accès à l'adresse identifiée par l'étiquette {} trop éloigné ({} octets d'écart) pour pouvoir être encodé",
        "L'étiquette {} n'est déclarée nulle part",
        "L'étiquette {} correspond à un décalage de {} octets, qui n'est pas un multiple de 4, ce qui est requis par ARM",
    ],

    "components": [
        "Invalid mode '{}'",
        "Le registre SPSR n'existe pas en mode 'User'!",
        "Le registre SPSR n'existe pas en mode 'User'!",
        "Tentative de lecture d'une instruction a une adresse non initialisée : {}",
        "Accès mémoire en lecture fautif a l'adresse {}",
        "Accès invalide pour une écriture de taille {} à l'adresse {}",
    ],

    "history": [
        "Fin de l'historique atteinte, impossible de remonter plus haut!"
    ],

    "mainweb": [
        "Information indisponible",
        "Veuillez assembler le code avant d'effectuer cette opération.",
        "Adresse mémoire invalide",
        "Valeur invalide: {}",
        "Registre invalide: {}",
        "Valeur invalide: {}",
    ],

    "simulator": [
        "Erreur : la valeur de PC ({}) est invalide (ce doit être un multiple de 4)!",
        "Information indisponible",
        "Adresse de l’instruction",
        "Erreur : {} devrait valoir {} (la valeur du registre R{}), mais il vaut {}\n",
        "Erreur : {} devrait valoir {}, mais il vaut {}\n",
        "Erreur : l'adresse mémoire {} devrait contenir {} (la valeur du registre R{}), mais elle contient {}\n",
        "Erreur : l'adresse mémoire {} devrait contenir {}, mais elle contient {}\n",
        "Erreur : le drapeau {} devrait signaler {}, mais il signale {}\n",
        "Assertion inconnue ou impossible à interpréter : ({}, {})!"
    ],

    "tokenizer": [
        "(01) Caractere invalide (ligne {}, colonne {}) : {}",
        "(02) Caractere invalide (ligne {}, colonne {}) : {}",
        "(03) Caractere invalide (ligne {}, colonne {}) : {}",
        "(04) Caractere invalide (ligne {}, colonne {}) : {}",
        "(05) Caractere invalide (ligne {}, colonne {}) : {}",
        "(06) Caractere invalide (ligne {}, colonne {}) : {}",
        "(07) Caractere invalide (ligne {}, colonne {}) : {}",
        "(08) Caractere invalide (ligne {}, colonne {}) : {}",
        "(09) Caractere invalide (ligne {}, colonne {}) : {}",
        "(10) Caractere invalide (ligne {}, colonne {}) : {}",
        "(11) Caractere invalide (ligne {}, colonne {}) : {}",
        "(12) Caractere invalide (ligne {}, colonne {}) : {}",
        "(12b) Caractere invalide (ligne {}, colonne {}) : {}",
        "(13) Caractere invalide (ligne {}, colonne {}) : {}",
        "(07b) Caractere invalide (ligne {}, colonne {}) : {}",
        "(14) Caractere invalide (ligne {}, colonne {}) : {}",
        "(15) Caractere invalide (ligne {}, colonne {}) : {}",
        "(16) Caractere invalide (ligne {}, colonne {}) : {}",
        "(17) Caractere invalide (ligne {}, colonne {}) : {}",
        "(18) Caractere invalide (ligne {}, colonne {}) : {}",
        "(19) Caractere invalide (ligne {}, colonne {}) : {}",
        "(20) Caractere invalide (ligne {}, colonne {}) : {}",
        "(21) Caractere invalide (ligne {}, colonne {}) : {}",
        "(22) Caractere invalide (ligne {}, colonne {}) : {}",
        "(23) Caractere invalide (ligne {}, colonne {}) : {}",
        "(24) Caractere invalide (ligne {}, colonne {}) : {}",
        "(25) Caractere invalide (ligne {}, colonne {}) : {}",
        "(26) Caractere invalide (ligne {}, colonne {}) : {}",
        "(G) Caractere invalide (ligne {}, colonne {}) : {}",
    ],

    "yaccparser": [
        "Une étiquette doit commencer par une lettre majuscule ou minuscule (et non par un chiffre)",
        "Instruction invalide : \"{}\". Veuillez vous référer au manuel du simulateur pour la liste des instructions acceptées. ",
        "Le registre R{}{} n'existe pas",
        "L'instruction {} requiert un registre comme premier argument",
        "Les registres et/ou constantes utilisés dans une opération doivent être séparés par une virgule",
        "Les registres et/ou constantes utilisés dans une opération doivent être séparés par une virgule",
        "L'instruction {} requiert 3 arguments",
        "Le registre R{}{} n'existe pas",
        "Le registre R{}{} n'existe pas",
        "TEST",
        "Impossible d'encoder la constante suivante ou son inverse dans une instruction {} : {}",
        "Impossible d'encoder la constante suivante dans une instruction {} : {}",
        "Le registre R{}{} n'existe pas",
        "Une virgule est requise avant l'opération de décalage",
        "Décalage {} invalide sans un paramètre (registre ou constante) indiquant le décalage",
        "Impossible d'encoder un décalage négatif ({}) dans une instruction (utilisez un autre opérateur de décalage pour arriver au même effet)",
        "Impossible d'encoder le décalage {} dans une instruction (ce dernier doit être inférieur à 32)",
        "Une instruction {} n'accepte pas de décalage sur son registre d'offset",
        "Le décalage de {} demandé dans l'instruction est trop grand pour pouvoir être encodé (il doit être inférieur à 256)",
        "Il est interdit d'utiliser STR avec une adresse d'étiquette pour cible. Par exemple, 'STR R0, a' est valide, mais pas 'STR R0, =a'.",
        "Il est interdit d'utiliser PC comme registre de base lorsque le writeback est activé.",
        "En mode writeback, il est interdit d'utiliser le même registre comme destination et adresse de base.",
        "Le décalage de {} demandé dans l'instruction est trop grand pour pouvoir être encodé (il doit être inférieur à 4096)",
        "Une opération de décalage doit être précédée par une virgule.",
        "PC ne peut pas être utilisé comme registre de décalage!",
        "Il est interdit d'utiliser PC comme registre de base en mode post-incrémentation!",
        "Le décalage de {} demandé dans l'instruction est trop grand pour pouvoir être encodé (il doit être inférieur à 4096)",
        "La cible d'un branchement doit être une étiquette (ou, pour BX, un registre). Une étiquette ne peut pas commencer par un chiffre.",
        "Une instruction {} doit spécifier au moins un registre dans sa liste.",
        "Il est interdit d'utiliser PC comme registre de base dans une opération mémoire multiple!",
        "Impossible d'affecter directement une constante dans un registre de statut.\nSeuls les drapeaux peuvent être directement modifiés, en ajoutant le suffixe _flg au registre de statut.",
        "Impossible d'encoder la constante suivante dans une instruction {} : {}",
        "Une instruction {} ne peut recevoir de constante comme dernier argument, seulement un registre.",
        "Une instruction {} ne peut recevoir plus de 3 registres en argument.",
        "Une instruction {} ne peut recevoir de constante comme dernier argument, seulement un registre.",
        "Le registre PC ne peut pas être utilisé.",
        "Le registre R{} ne peut être utilisé plus d'une fois.",
        "Une variable peut avoir les tailles suivantes (en bits) : 8, 16 ou 32. {} n'est pas une taille valide",
        "Une assignation de variable doit être suivie d'une taille en bits (par exemple ASSIGN32 ou ASSIGN8)",
        "Une variable peut avoir les tailles suivantes (en bits) : 8, 16 ou 32. {} n'est pas une taille valide",
        "Une allocation de variable ne peut qu'être suivie d'un nombre d'éléments. Utilisez ASSIGN si vous voulez assigner des valeurs précises.",
        "Demande d'allocation mémoire trop grande. Le maximum permis est de 8 Ko (8192 octets), mais la déclaration demande {} octets.",
        "Une allocation de variable doit être suivie d'une taille en bits (par exemple ALLOC32 ou ALLOC8)"
    ],
}
